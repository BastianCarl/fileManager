JWS vs JWE

JWS = Json web signature
    content is visible
    content is Base64 encoded

JWE = Json web encryption
    content is not visible
    content is encrypted

JWT uses either JWS or JWE

-------------------------------------------------
HTTPS(SSL/TTL) requires both TrustStore and KeyStore

TrustStore(stores information about others)
    stores SSL certificates(self-signed and CA signed) of external trusted entities
    used during SSL handShake
    used for HTTP connections
    checks API's server certificate is trusted

KeyStore(stores information about us)
    vault used for storing private keys, certificates

HOW TO?
    Create a KeyStore
    Generate a SSL Certificate
    Import SSL Certificate to KeyStore
    Configure Tomcat to use it

The keystore is where you store your own private keys and certificates
The truststore contains certificates from other entities that you trust (typically from Certificate Authorities or trusted servers).
------------------------------------------------------------------

Constants vs final
    constants is final static
    final is final
--------------------------------------------------------------------------

s3 vs disk
    SSD 0.2–0.5 ms
    HDD 5–10 ms
    AWS EBS
    AWS EFS
    AWS S3 20–100 ms rata buna de Throughput

---------------------------------------------------------
hashing vs criptat vs encodat
    Hash:
        keys, hash functions, digest, collision
        hash values itself stores no data
        used for integrity checking, hash table(store and retrieve) uses hashes as index
        irreversible
        fix length
    Encryption:
        reversible
        data --> cipher text (unreadable data) --> original data
        used for sending sensible information
        key-based:
            symmetric:
                shared key between sender and receiver
                encryption and decryption use the same key
                faster, less secured
                limited data
                used for encryption
            asymmetric:
                private-public key are related
                one key encrypt and other one decrypt
                slower, more secured
                bulk date
                to prove that someone sent a message uses private key to encrypted an
                used for encryption, and signatures(integrity and authentication)
            symmetric + asymmetric(hybrid encryption used TLS/SSL):
                used asymmetric keys to share symmetric key
                used symmetric key to share bulk data
    Encoding:
        transformation based on a set of rules (binary, hexadecimal, base64)
        data representation
        reversible
    CA:
        CA is trusted by the client
        CA sings a certificate that proves a particular asymmetric public key belongs to a domain
        CA has its own private-public keys
        CA has self-signed certificate(including CA public key)
        CA generates certificate for serves and also sign wit CA's private key
        Client(browser) has CA certificates installed
        Client verifies server's certificate is legitimate (issued by CA)
        Client verifies that certificate belongs to server (check that private key belongs to server)
        Digital Signature is a proof that something belongs to somebody and its content was not altered
        A self-signed certificate is a digital certificate not validated by a trusted Certificate Authority (CA), but instead signed by its own private key.
-------
JVM-ul trebuia sa fie portabil si sa ruleze identic pe orice OS, fara sa depinda de infrastructura sistemului de operare.
C# a fost gandit initial strict pentru Windows
-----
trusted root = what CA I trust, therefore all certificates form this authorities are trusted
personal certificates =  store certificates related to you. Certificates with private keys associated with you
-------------------
500/501
--------------------
Root Certificate
    can emit Intermediate certificates
    It is the certificates that is directly trusted by client
    has a public key
    if it's compromised than all intermediate and end-user certificates are compromised
Intermediate (proxy for root)
    it's trusted by client only if the root is also trusted by client
    sign with root private key
    has a public key
end user certificate (SSL)
    belongs to a domain and proves that a private-key pair belong to the host
    has a public key
    sign with private the of intermediate certificate that emitted the certificate
    it's trusted only if the issuer (intermediate) is trust
Chain of trust
    Browser verifies that intermediate certificate is legit and is emitted by one of the root certificate and therefore trust it
    Browser verifies that end-user certificate is legit

PKI
    server
    client
    CA
MAC's alternative for signatures
tls handshake
    Client Hello
    Server Hello
    Certificate
    key exchange
-------------------------

1xx - Informational
    web sockets
| Cod     | Status                          | Descriere                                                                                                               |
| ------- | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| **200** | OK                              | Cererea a avut succes; semnificația exactă depinde de metoda folosită (GET, POST, etc.).                                |
| **201** | Created                         | Cererea a fost completată și a fost creată una sau mai multe resurse noi.                                               |
| **202** | Accepted                        | Cererea a fost acceptată, dar nu a fost încă procesată; util pentru procesare batch.                                    |
| **203** | Non-Authoritative Information   | Cererea a reușit, dar răspunsul a fost modificat de un proxy sau sursă terță; se folosește pentru cache sau backup-uri. |
| **204** | No Content                      | Cererea a fost procesată cu succes, dar nu există conținut de returnat.                                                 |
| **205** | Reset Content                   | Cererea a fost procesată; clientul trebuie să reseteze documentul sau vizualizarea.                                     |
| **206** | Partial Content                 | Serverul a returnat doar o parte a resursei (de obicei pentru Range requests).                                          |
| **207** | Multi-Status                    | Răspunsul oferă status pentru mai multe resurse într-un singur mesaj (XML).                                             |
| **208** | Already Reported                | Evită listarea duplicatelor într-o colecție WebDAV; doar o resursă raportează 200 OK.                                   |
| **226** | IM Used                         | Cererea GET a fost procesată, iar serverul a aplicat manipulări de instanță asupra resursei.                            |
| **300** | Multiple Choices                | Resursa are mai multe variante; clientul trebuie să aleagă una. Include liste de opțiuni și locații.                    |
| **301** | Moved Permanently               | Resursa a fost mutată permanent la un nou URL; toate cererile viitoare trebuie să folosească noua adresă.               |
| **302** | Found                           | Resursa este temporar disponibilă la un alt URI; cererile viitoare pot continua să folosească adresa originală.         |
| **303** | See Other                       | Redirectează clientul către alt URI folosind metoda GET; de exemplu, după trimiterea unui formular.                     |
| **304** | Not Modified                    | Resursa nu s-a modificat; clientul poate folosi versiunea din cache.                                                    |
| **307** | Temporary Redirect              | Redirecționează temporar clientul; metoda HTTP trebuie păstrată.                                                        |
| **308** | Permanent Redirect              | Resursa a fost mutată permanent; metoda HTTP nu poate fi schimbată.                                                     |
| **400** | Bad Request                     | Cerere invalidă din cauza sintaxei greșite sau rutei incorecte.                                                         |
| **401** | Unauthorized                    | Lipsă/invalidare autentificare; serverul respinge cererea.                                                              |
| **402** | Payment Required                | Rezervat pentru sisteme de plată, rar folosit.                                                                          |
| **403** | Forbidden                       | Cererea înțeleasă, dar accesul este interzis.                                                                           |
| **404** | Not Found                       | Resursa nu există sau nu are adresă de redirecționare.                                                                  |
| **405** | Method Not Allowed              | Metoda cerută nu este permisă pentru resursă.                                                                           |
| **406** | Not Acceptable                  | Conținutul nu corespunde cu header-ul `Accept`.                                                                         |
| **407** | Proxy Authentication Required   | Necesită autentificare prin proxy.                                                                                      |
| **408** | Request Timeout                 | Serverul nu a primit cererea completă la timp.                                                                          |
| **409** | Conflict                        | Conflict cu starea curentă a resursei.                                                                                  |
| **410** | Gone                            | Resursa a fost eliminată definitiv.                                                                                     |
| **411** | Length Required                 | Lipsă header `Content-Length`.                                                                                          |
| **412** | Precondition Failed             | Condițiile din header nu au fost îndeplinite.                                                                           |
| **413** | Payload Too Large               | Cererea este prea mare pentru a fi procesată.                                                                           |
| **414** | URI Too Long                    | URI prea lung pentru a fi procesat.                                                                                     |
| **415** | Unsupported Media Type          | Format de media nesuportat.                                                                                             |
| **416** | Range Not Satisfiable           | Domeniul solicitat nu este valid pentru resursă.                                                                        |
| **417** | Expectation Failed              | Serverul nu poate îndeplini cerințele din `Expect`.                                                                     |
| **418** | I’m a Teapot                    | Cod de glumă, serverul este un ceainic.                                                                                 |
| **421** | Misdirected Request             | Cererea a fost trimisă către serverul greșit.                                                                           |
| **422** | Unprocessable Entity            | Resursa nu poate fi procesată (eroare semantică).                                                                       |
| **423** | Locked                          | Resursa este blocată.                                                                                                   |
| **424** | Failed Dependency               | Cererea a eșuat din cauza unei dependențe.                                                                              |
| **425** | Too Early                       | Serverul refuză cererea pentru a evita repetarea.                                                                       |
| **426** | Upgrade Required                | Necesită schimbarea protocolului.                                                                                       |
| **428** | Precondition Required           | Serverul cere o solicitare condiționată.                                                                                |
| **429** | Too Many Requests               | Prea multe cereri într-un interval scurt.                                                                               |
| **431** | Request Header Fields Too Large | Header-ele sunt prea mari pentru a fi procesate.                                                                        |
| **451** | Unavailable for Legal Reasons   | Resursa indisponibilă din motive legale.                                                                                |
                                                    |

3xx - Redirection
    301 - moved permanently
    304 - Not modified (resursa se afla deja in cache deci nu mai e nevoie sa fie descarcata si poata folosi direct din cache)
    307	- Temporary Redirect

5xx - Server Error
    500 - Internal server error
-----
HashTable
    uses a hashTable
HashTree
    Red–black tree (Heap)

LinkedList este dublu-inlantuita

 immutability
        a class whose instance cannot be modified
        how to
            dont provide setters
            final class
            all fields are private final
            all mutable objects are inaccessible out of class
    Advantages
        thead-safe
        optimized at run-time

-----
key should be immutable, equals and hascode

--------------
Conditional request
    where the result, and even the success of a request, can be controlled by comparing the affected resources with a validator
    These headers define a precondition, and the result of the request will be different if the precondition is matched or not (If-Match, If-None-Match)
    304
    Etag is an identifier for a specific version of a resource
    used for:
        Prevent a (heavy) response payload if the client has a cached representation that's still the same as on the server
        Prevent an update if the client has an older version than the server
    etag header
--------------
Java features:
    1. Reflection
    5: Generics, Concurrent Collections
    7: try-with-resources, diamond operator(determines the most suitable constructor)
    8: lambda expressions, stream, default methods interface
    10: var
    12. Switch Expression
    14. Records - immutable class
    15. Sealed Classes(more fine-grained inheritance control), Hidden Classes
    16. Pattern Matching
    25. Flexible Constructor Bodies

atomic = single, indivisible operations
Thepossibility of incorrect results in the presence of unlucky timing is so importantin concurrent programming that it has a name: a race condition.
Concurent collections
    - thread-safe(correctness) collection classes known as Concurrent Collections.
    - improved lock mechanism (segment locking mechanism)

Synchronized
    - less efficentet than concurent collections due to lock mechanism

Non-concurent collections
    - For every operation  only one thread can access the entire collection at a time -> performance problems
    - if one thread is iterating over a collection and another thread tries to modify it concurrently, it results in a ConcurrentModificationException.

colectie concurenta vs cand o colectie imutabila:
    both are thread-safe
    imutable is read-only

Creational design patterns:
    1. Factory
        simple factory
        factory design
    2. Abstract
    3. Builder
    4. Singleton
    5. Prototype

   -----
   Reflection nu poate fi folosit pentru a face metode/field-uri
   When you execute something synchronously, you wait for it to finish before moving on to another task.
   When you execute something asynchronously, you can move on to another task before it finishes.
   Concurrency is about dealing with lot of things at once, Parallelism is about doing a lot of things at once"
   Concurrency
        - context switching.
        - efficiently managing multiple task
    Parallelism
        - multiple central processing units


 synchronized on the Class object (only one thread can use this method)
 Instance methods are synchronized over the instance of the class owning the method, which means only one thread per instance of the class can execute this method.

 When working with files, streams, or other resources, it is important to close them after use. If you forget to close a resource,
  it may keep using memory or even prevent you from opening the file again until the program ends.

  Closeable vs Autocloseable
    - closeable is meant to be used with I/O, throws I/O Exception
    - autocloseable is more generic, throws exception

Files Handlers
    Closes this file input stream and releases any system resources associated with the stream.
    Locked Files
    Each open file uses a file descriptor. Most operating systems limit the number of open file descriptors per process (Too many open files)
    The garbage collector will definitely clear the memory if there is no longer a reference to the open file. However, it will happen only when the collector runs.
    Until that point, that resource stays in memory.

Interfete
    Clasa care implemnetreza trebuie sa fac override la metoda default mostenit

effectively final
  variabila a fost initializata in momentul in care a fost creeata si ulterios si a ulterior nu s-a facut alta atribuire

Pattern Matching
    - instace of (type pattern)
    - switch
    - records(extraction)
    - Data Oriented programming
----------------
 graal
    - jdk (JVM, javac, jit, jre)
    - native Image feature transforms java code (not byte) in binary code (/bin/bash)

 AOT
    - Ahead-of-time optimization
    - AOT compilation refers to the process of transforming high-level programming code into machine code before the program runs.
    - In traditional Java applications, the Just-in-Time (JIT) compiler compiles code during runtime, which can introduce some delays.
    - With AOT, Spring 6 aims to overcome these delays by performing the compilation ahead of time, which improves startup performance and resource usage.

    Java code
        int a = 5;
        int b = 3;
        int c = a + b;
        int d = a - b;

    Byte code
        0: iconst_5
        1: istore_1
        3: istore_2
        4: iload_1
        5: iload_2
        6: iadd
        7: istore_3
        8: iload_1
        9: iload_2
        10: isub
        11: istore

    Machine code
        mov     eax, 5        ; a = 5
        mov     ebx, 3        ; b = 3
        mov     ecx, eax
        add     ecx, ebx      ; c = a + b
        mov     edx, eax
        sub     edx, ebx      ; d = a - b

-------------

CAS(Compare and swap)
    - a lock free lock solution to update the state
    - more performance
    - more complex
Lock
    a synchronization mechanism that allows only one thread to access a critical section of code at a time.
    Locks are a blocking mechanism
        - less performance
        - less complex

 atomitic
    - wrapper
    - atomic writing and reading
    - visibility(volatile is useless for atomic)

Metode din Object class
    toString
    hashCode
    equal
    finalize
    getClass
    clone
    wait(), notify() notifyAll()

Functional interface
    Conceptually, a functional interface has exactly one abstract method.
    Since default methods have an implementation, they are not abstract.
    If an interface declares an abstract method overriding one of the public methods of java.lang.Object,
    hat also does not count toward the interface's abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.
Override
 Indicates that a method declaration is intended to override a method declaration in a supertype.

 Properties in Spring
    Command-line arguments (--server.port=8081)
    Java system properties (-Dserver.port=8082)
    Environment variables (SERVER_PORT=8083)
    Application property files

Creational Design Pattern
    - Simple Factory
    - Factory Method
        - replace direct object construction calls (using the new operator) with calls to a special factory method
    - Abstract Factory
        - lets you produce families of related objects without specifying their concrete classes.
    - Builder
        - lets you construct complex objects step by step
Volatile
    the values should be directly read/write from main memory and not from cache
    when you write to volatile variable then all variable visible to that write will be written directly to main memory(RAM)
    when you read a volatile variable then all variables visible to that thread will be read from main memory
    happens before guarantee
        - all writes to non-volatile should be before write to volatile variable
        - all reads to non-volatile should be after read to volatile variable
Override
    - attempting to assign weaker access privileges ('private'); was 'packageLocal'
    - private < default < protected < public
    - Covariant  return type
        - a subtype of the overridden method's return type.
    - Exceptions
        - runtimeException no limitation
        - checked exception must be a subtype of the parent exception

wait(), notify() notifyAll()
    - used for thread sycronization
    - wait tells a thread to wait untill a notify/notifyAll is called on the same object
    - notify tells a thread that is waiting to continue
    - notify tells all threads that are waiting to continue
Overloading with Collections
    - uses the method with the most specific parameters in relation with argument (maybe instance of)

Core vs thread vs process?
https://kishoreconnect.com/understanding-processes-threads-and-cpu-cores


        - Program(code) + Resources(Memory(stack, heap), CPU)
    Thread
        -it's also called lightweight process. Subprogram + resources(stack)
    Core
     - core = max number of parallel threads
      - CPU
Se poate un proces sa nu aiba thread-uri?
    Threads exist within a process — every process has at least one.

Factory Method
    - Orientat pe serviciu si nu pe obiectul care face serviciul(Curier)
Abstract Factory
    - vreau un set de elemente compatibil (ecosistem)
Builder
    - vreau sa fie ca si a vecinului
Prototype
    - lego

concurrentHashMap: computeIfAbsent, computeIfPresent, merge
    - used to defeat slipped conditions
--------------------------------------------
Throwable
    - Exception
        - exceptional conditions that user programs should catch
        - Runtime exceptions are unchecked(not needed to be handled)
        - All other exceptions are checked
    - Error
        - which defines exceptions that are not expected tobe caught under normal circumstances
        - represents catastrophic failures that cannot usually be handled by your program.
The default handler displays a string describing the exception, prints a stack trace from the point at which the exception occurred, and terminates the program.
wait vs Thread.sleep
    wait notify/notifyAll can only be used in synchronized context because they use monitor
    wait release the monitor sleep doesn't
JVM memory
    - registrii
        - zone de stocare foarte rapide din interiorul unui core
        - fiecare core are properiu set de registrii
    - L1, L2, L3 cache
        - L1, L2, apartin unui singur core
        - L3 este partajat de toate core-urile
    - RAM
        - Heap
            - objects
        - Stack
            - primitives, references
    registrii > L1 > L2 > L3 > RAM
ClassLoader
    - Classes are loaded into the JVM on an 'as needed' basis
    - bootstrap class loader that is built into the JVM is responsible for loading the classes of the Java runtime.
    - In addition to the bootstrap class loader, the JVM has an extension class loader responsible for loading classes from standard extension APIs, and a system class loader that loads classes from a general class path as well as your application classes.
    - The java.lang.ClassLoader is an abstract class
Initialization
    The first time a class is touched(whether that’s by creating an object, accessing a static field, or calling a static method) during this process, the JVM performs static initialization.
    static initializer are executed as the appear and only once
    the program reaches a new expression, Java allocates memory for the new object on the heap. At this stage, all instance fields of the object are filled with default values,
    Order of execution
        Super
            -field assignments and instance initialization blocks
            - constructor
        Current
            - field assignments and instance initialization blocks
            - constructor
Design patterns
    - Decorator
        - Uses an intermediate class
        - used for adding additional capabilities
        - keep the same interface
        - Read about inputStream bufferedInputStream
        - used for Open/Closed principle
        - Used as alternative for Inheritance
    - Adapter
        - Uses an intermediate class
        - used for making two incompatible things to work
        - not used for adding additional capabilities
    - Proxy
        - Uses an intermediate class
        - used for controlling input/output (Cache, Security, Logging)
        - not used for adding additional capabilities
    - Facade
        - avoid tight coupling between clients and subsystems
        - Facade provides convenient access to a particular part of the subsystem’s functionality
        - faced contains a particular feature of a system
        - consultant, front desk assistant
        - simplify a complex system
        - combine different functionalities to offer a new functionality
    - Flyweight
        - separate object's field into two categories: intrinsic(constant) extrinsic(changeable)
        - put intrinsic fields into a separate class
        - optimize memory by storing the same object just once
---------------------------------
Thread Status
    - New
        - created but not started yet
    - Runnable
        - either running or waiting for scheduler to give resources
    - Blocked
        - waiting for the monitor(waiting to enter a synchronized method or code block)
    - Waiting
        - waiting for another thread
        - wait
        - join
    - Timed Waiting
        - waiting for another thread to perform a particular action within a stipulated amount of time
        - wait(long millis))
        - join(long millis))
        - sleep(long millis))
    - Terminated
        - after finishing the execution
ClassLoader
    1.Application ClassLoader
        - loads from classes from Java Runtime Image
    2.Platform Class Loader
         - loads from classes from Java Runtime Image and any other module specified by the system property java.platform or --module-path.
    3.Bootstrap ClassLoader
        - loaded from directories specified by the environment variable CLASSPATH, the -classpath or -cp

Behavioral Patterns
     Observer
        - define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.
        - Observable -> Observers ( 1 -> many relationship)
        - when Observable stats is changed all Observers are notified
     Command
        - Invoker -> Command (1 -> many relationship)
        - Command -> receiver (1 -> receiver)
        - Command has 2 methods: execute and unexecute
        - Receiver has 1 method: action that actually does the work
        - acts as proxy between Invoker and Receiver
     Strategy
        - using composition instead of inheritance for code reuse
        - families of algorithms
        - help reuse code for non-hierarchy relationship
     State
        - behave differently depending on the current state
        - events
        - actions(events)
        - action + state = transition(new sta te)
        - replace conditions such as if (state == sth & action == sth2) with polymorphic;
        - avoid to miss a particular case
     ChainOfResponsibility
        - Chain of handlers
        - allows to execute handlers in a particular order
        - deals with a different kinds of requests
        - avoid using of if  if(condition) -> handlers
        - each handler has a handlingMethod and a reference to next handler in the chain
        - only a handler handles a requests (not sure)
        - a handler can either process or pass the requests(not sure)
        - avoid using of nested ifs
     Template Method
        - Let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure
        - used for code reuse
        - similar with Strategy
    Bridge
        - allows to compose different thinks instead of creating for each possible combination
        - split a large class or a set of closely related classes into two separate hierarchies
        - Decoupling interface and implementation??????
    Iterator
        - collections
        - Iterable
        - Iterator
            - hasNext()
            - next()
            - current()
            - linkedList vs ArrayList
    Composite
        - used hierarchy structures
        - Component
            - Leaf
            - Composite
        - avoid individual interaction
    Visitor
        - Defines an utility class used by other classes
        - defines an algorithm in many forms so that it suits each class that uses it
        - add new operations to preexisting classes without changing them
        - allows iterating through a collections of different objects and execute a specific algorithm for each element(overloading) alternative of instance of
    Mediator
        - avoid direct communication between two component
        - similar with Command but is bidirectional
        - Mediator is responsible for business logic
        - all component just notify Mediator
        - Mediator acts as God
    Momento
        - save and restore the previous state of an object
        - can be used with command
Transactional
    - it wraps your method call in a transactional boundary
    - Automatically starts, commits, or rolls back a transaction
    - It creates a proxy (JDK or CGLIB) around your bean
    - This proxy intercepts method calls and delegates to a TransactionManager
Propagation
    - control of transaction boundaries
    - REQUIRED
    - REQUIRES_NEW
    - SUPPORTS
    - NOT_SUPPORTED
    - MANDATORY
    - NEVER
    - NESTED
Isolation
    - Isolation levels define how data accessed by one transaction is isolated from other transactions
    - DEFAULT
    - READ_UNCOMMITTED
    - READ_COMMITTED
    - REPEATABLE_READ
    - SERIALIZABLE
-----------------------
Reference
    https://web.archive.org/web/20100819115659/http://weblogs.java.net/blog/2006/05/04/understanding-weak-references
    Hard(Strong)
    - The object can’t be garbage collected if it’s reachable through any strong reference
    - List<String> list = new ArrayList<>;
    Soft
    - A soft reference tells the garbage collector that a referenced object can be collected at the collector’s discretion
    - SoftReference<List<String>> listReference = new SoftReference<List<String>>(new ArrayList<String>());
    - That’ll happen, especially when JVM is at risk of running out of memory
    - memory-sensitive cache
    - All soft references to softly-reachable objects are guaranteed to have been cleared before the virtual machine throws an OutOfMemoryError
    Weak
    - A weakly referenced object is cleared by the Garbage Collector when it’s weakly reachable.
    - Weak reachability means that an object has neither strong nor soft references pointing to it.
    - Objects referenced only by weak references aren’t prevented from being collected
    - to create canonicalizing mappings
    Phantom
    -  enqueued after the collector determines that their referents may otherwise be reclaimed
Rule: Strong reference ensures that the object wont be collected by GC. Soft and Weak offers a way to access the object, without ensuring the object won't be collected by CG
Domain Driven Design
    - Strategic Design
        - overview of the app
        - how app works
        - flows
        - edge case-uri
        - define business requirements
        - ubiquitous language
        - Core domains
        - Subdomain
    - Tactical Design (Technical zone)
        - Bounded Context (Subdomain)
        - Entities(class)
        - Value objects(Fields)
    - Aggregate
        - a class which has classes as dependencies
        - a group of entities
    - Service
        - logic
        - no state
AOP
    - complementary for OOP
    - used for crosscutting concern
        - logging
        - performance monitoring
        - exceptions
        - validations
    - uses a proxy
    - @Aspect && @Component
    - Aspect = feature used for multiples classes
    - JointPoint = point during the execution of a program
    - Advice = what to execute
        - Before advice
        - After advice
        - After returning advice
        - After throwing advice
        - Around advice
    - Pointcut: A predicate that specifies for which method to be executed
Cache
    - Write-Through
        - In write-through, data is simultaneously updated to cache and memory
        - questions the advantage of having a cache in write operation
        - worse performance
        - more reliable
    - Write-Back(Write-behind)
        - The data is updated only in the cache and updated into the memory at a later time
        - better performance
        - less reliable
    - Cache aside (Lazy loading, write-around)
        - data is written directly to the main memory, bypassing the cache. The cache is only updated if the same data is read again.
        - cache stays slim and contains only the data needed
        - gets filled only after a cache miss
        - logic is in the core application
    - Read-Through
        -  In a read-through cache, data is loaded into the cache on demand, typically when a read request occurs for data that is not already in the cache.
    - Read Ahead
        - Allows the controller to read sequentially ahead of the requested data and store the additional data in cache memory
        - This process speeds up reads for sequential data, but there is little improvement when accessing random data.

Isolation Levels
    - Transaction isolation levels define how concurrent transactions interact to maintain data consistency and integrity(how much a transactions is affected by another transaction)
    - Read Uncommitted
        - transaction can see uncommitted changes made by other transactions
    - Read Committed
        - transaction can only see changes made by other committed transactions
        - non-repeatable read
    - Repeatable Read
        - transaction will see the same data throughout its duration, even if other transactions commit changes to the data
        - This level ensures that if you read a row in a transaction, it stays the same throughout that transaction
        - phantom reads
    - Serializable
        - It makes transactions behave as if they’re running one after another, completely isolated.
        - lock the whole table
        - serially executing.
    - *Snapshot
        - similar with Serializable
    - Problems
        - Dirty Read: Reading uncommitted changes that might get rolled back. (Read Uncommited)
        - Non-repeatable Read: Seeing different data for the same row within one transaction.(Read Uncommited, Read Uncommited)
        - Phantom Read: Seeing new or missing rows in the same query within one transaction. (Read Uncommited, Read Uncommited, Repeatable Read)
        - Lost updates: two concurrent transaction modifies the exact data. (Read Uncommited, Read Uncommited)
ACID
    Atomicity
    - all the queries in a transactions must succeed
    - if one query fails all the successful queries must be rolled back
    Consistency
    - Consistency in Data
        - Referential Integrity
    - Consistency in Read
        - If a transaction commited a change a new transaction will immediately see the change
    Isolation
        - how much a transaction see what another transaction modifies
    Durability
        - changes made by commited transactions must be persisted in a durable non-volatile storage system(disk vs ram)
        - durability technics
            - WAL (write ahead log )
            - Snapshot
            - AOF
 Domain-Driven Design (DDD)
    Domain
        - concept specific to a particular domain: account, transactions, customer, refund
    Driven
        - influenced by
    Design
        - blueprint of a software system
    Strategic Design
        - focuses on defining the overall architecture
        - It addresses high-level concerns
        - Bounded Context (exemplu seo)
            - particular area from a larger problem
            - contains specific terms(terminology) that may have a different meaning in other areas

-------------
 Domain-Driven Design (DDD)
 - With DDD we're looking to create models of a problem domain. The code is the model.
 - This then is the first of the DDD patterns: a model-driven design. It means being able to map - ideally quite literally - the concepts in the model to those of the design/code.
 - A change in the model implies a change to the code; changing the code means the model has changed.
 - DDD advocates that the domain experts and developers consciously communicate using the concepts within the model. -> ubiquitous language.
 - Whenever we discuss a model it's always within some context
 - Every domain model lives in precisely one Bonded Context
 - relationships between these BCs. (Context mapping)
    - published language
    - open host service
    - shared kernel
    - customer/supplier
    - conformist
    - anti-corruption layer

    Definitions
    domain
    A	 sphere	 of	 knowledge,	 influence,	 or	activity.	The	 subject	area	 to	which	 the	 user	applies	a
    program	is	the	domain	of	the	software.

    model
    A	 system	 of	 abstractions	 that	 describes	 selected	 aspects	 of	 a	 domain	 and	 can	 be	 used	 to
    solve	problems	related	to	that	domain.

    ubiquitous	language
    A	 language	 structured	 around	 the	 domain	 model	 and	 used	 by	 all	 team	 members	 within	 a
    bounded	context	to	connect	all	the	activities	of	the	team	with	the	software.

    context
    The	setting	in	which	a	word	or	statement	appears	 that	determines	its	meaning.	Statements
    about	a	model	can	only	be	understood	in	a	context.

    bounded	context
    A	description	of	a	boundary	 (typically	a	subsystem,	or	the	work	of	a	particular	team)	within
    which	a	particular	model	is	defined	and	applicable
- Model
    - Model is a representation of the domain having a couple aspects(narrow) and being suitable for a particular problem.

- Entities
    - Concept of identifier equality refers to entities.
    - may change
    - have identity
- Value Object
    - Whereas the concept of structural equality.
    - cannot change
    - doesn't have identity
- Services
    - When a significant process or transformation in the domain is	not	a natural responsibility
      of an entity or value object
    - Services encapsulate domain logic that operates on multiple objects or orchestrates interactions between objects.
    - Services are typically stateless and focus on performing specific tasks or enforcing domain rules.
- Aggregates
    - Cluster the entities and value objects into aggregates and act as single unit
    - Each Aggregate has a Aggregate Root which is responsible for the synchronization of the other members of the aggregates
- Repositories
    - They provide a consistent interface for querying and storing domain objects.
- Domain Events
    - Something	happened that domain experts care about.
- Bounded Context
    - exists as consequences of the ubiquitous language
    - a part of the domain where term(models) have a particular meaning

stampede cache
    - A situation when cache expired and multiple similar request are occurring causing a response time too long
    - Solutions
        - Locking
            - first request causes cache revalidating and lock the cookie. Other request must wai until the ache refresh is done without creating a new cache revalidating request
        - stale-while-revalidating
            - first request causes cache revalidating and gets back a stale value. All other request receive a stale value until cache revalidation in done.
Phantom Reference
    - An object becomes phantom reachable after it has been finalized, but before the memory is reclaimed.
    - When the garbage collector determines that an object is phantom reachable, it adds the phantom reference to the reference queue,
    - allowing the application to perform post-mortem cleanup actions before the object’s memory is actually reclaimed
Finalization
    - Just before destroying any object, the garbage collector always calls the finalize() method to perform clean-up activities on that object.
    - The primary purpose of finalize() is to release resources like file handles, network connections, or database connections that the object holds before it is destroyed.
Phantom Reference vs Finalization
    - It can be used instead of a finalize method, guaranteeing that the object is not resurrected during finalization.
    This allows the object to be garbage collected in a single cycle, rather than needing to wait for a second GC cycle to ensure that it has not been resurrected.
    - Detect exactly when an object has been removed from memory, ensuring that its memory is available, for example deferring allocation of a large amount of memory (e.g., a large image) until previous memory is freed.

Clean Architecture
    - one concern per component
    - structured in layers of dependency
    - Domain (core business logic)
        - Entities
        - Value Objects
        - Domain Events
        - Domain Services
        - Interfaces
        - Exceptions
    - Application (Use Case or flows)
        - Orchestrate the domain
        - business logic
    - Presentation Layer (API)
        - defines entry points to the system
    - Infrastructure (External Services)
        - databases
        - aws
